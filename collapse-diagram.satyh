@require: class-slydifi/theme/arctic
@require: class-slydifi/slydifi
@require: ruby/ruby
@require: easytable/easytable
@require: bibyfi/bibyfi
@require: bibyfi/bibyfi-IEEETran
@require: azmath/azmath
@require: matrix/matrix
@require: colorbox/colorbox
@require: arrows/arrows
@require: arrows/commands
@require: fss/fss
@require: fss/fonts
@require: latexcmds/latexcmds
@require: fss/style
@require: base/list-ext
@require: enumitem/enumitem
@require: figbox/figbox
@require: arrows/arrows
@require: base/list-ext
@require: colorbox/colorbox
@require: bibyfi/bibyfi
@require: annot
@import: tikzyfi
@import: utils
@import: macros

module Collapse : sig
  val diagram: int -> TikZyFi.element list
  type ordinal
  type universe
  type presense
  val make: universe list -> ordinal list -> int -> TikZyFi.element list
end = struct
  open Utils
  open TikZyFi
  open List

  
  type presense = 
      | Sticky
      | BecomesOmega1 of int * int option
      | Destroyed of int
  type ordinal = Ordinal of string * math * length * presense
  type universe = Universe of string * math * length

  let draw-universe: universe -> element list =
    fun (Universe (name, univ, x)) ->
      (let on = name ^ `-On` in
        [ node-at ?:[named name] (coord (x, 0cm)) {${#univ}}
        ; node-at ?:[named on] (coord (x, 10cm)) {${\On}}
        ; arrow (north-of name) (south-of on)
        ]
      )
  
  let default-universes: universe list =
    [ Universe (`V`, ${V}, -5cm)
    ; Universe (`V-Glam`, ${V[G \restr \lambda]}, 0cm)
    ; Universe (`V-G`, ${V[G]}, 5cm)
    ]
  
  let default-ordinals: ordinal list =
    [ Ordinal (`omega`, ${\omega}, 1.5cm, Sticky) 
    ; Ordinal (`omega1`, ${\omega_1^V}, 2.5cm, Destroyed 1)
    ; Ordinal (`omega2`, ${\omega_2^V}, 3.5cm, Destroyed 1)
    ; Ordinal (`lambda`, ${\lambda}, 6.0cm, BecomesOmega1 (1, Some 2))
    ; Ordinal (`lambda-pow`, ${(2^\lambda)^V}, 7.0cm, Destroyed 2)
    ; Ordinal (`kappa`, ${\kappa}, 8.75cm, BecomesOmega1 (2, None))
    ]

  let destroy-level p = match p with
    | Sticky -> None
    | Destroyed i -> Some i
    | BecomesOmega1 (_, i) -> i

  let becomes-omega-1 p = match p with
    | BecomesOmega1 (i, _) -> Some i
    | _ -> None

  let make univs ords layer =
    let num-colls = List.length (List.filter (fun (Ordinal (_, _, _, p)) -> Option.is-some (destroy-level p)) ords)
    in concat 
      [ concat-mapi
          (fun i (Universe (univ-name, _, x))-> 
            ( let omega-name = univ-name ^ `-omega` in
              let-mutable coll-count <- 0 in
              concat-mapi (fun j (Ordinal (ord-name, ord, y, presense)) -> (
                let start-layer = Int.max (2 * (i - 1) + 2) 0 in
                let name = univ-name ^ `-` ^ ord-name in
                let () = 
                  Option.map-or () 
                    (fun _ -> (coll-count <- !coll-count + 1))
                  (destroy-level presense) in
                let col = 
                  if i == 0 || layer < start-layer || Option.map-or true (fun l -> i < l) (destroy-level presense)
                  then Color.black
                  else emph-color
                in 
                let is-phantom = Option.map-or false (fun l -> i >= l && layer >= 2 * l + 1) (destroy-level presense)  in
                let is-omega-1 = 
                    not is-phantom &&
                    Option.map-or true 
                      (fun l -> 2 * (l - 1) + 3 <= layer && i >= l
                      && Option.map-or true (fun d -> i < d) (destroy-level presense)) 
                      ( becomes-omega-1 presense)
                      
                      in
                let memori = polyline ?:[pc col; phantom is-phantom] (map coord [(x -' 5pt, y); (x +' 5pt, y)]) in
                let ord-node = node-at ?:[named name; tc col; phantom is-phantom] (coord (x +' 7mm, y -' 4pt)) {\small{${#ord}}} in
                let omega1-node = 
                    Option.to-list 
                      (Option.map 
                        (fun l -> 
                          (let om-1-uni = 
                                Option.map-or ${} (fun (Universe(_, u, _)) -> u) (List.nth l univs )
                            in node-at ?:[phantom (not is-omega-1)] (move-to (east-of name) (2pt, -2pt)) {\small{${ = \omega_1^{#om-1-uni}}}}
                          )
                        )
                        (becomes-omega-1 presense) 
                      )
                in let destroyer = 
                    (Option.map-or []
                      (fun l ->
                        (if i == l  && layer == 2 * (l - 1) + 2
                          then
                            let off = float !coll-count in
                            let omega =
                                  between ?:(off /. float (num-colls - 1)) 
                                  (move-to (east-of omega-name) (0pt, 2pt *' float num-colls))
                                  (move-to (east-of omega-name) (0pt, -2pt *' float num-colls))
                                  in
                            let self = east-of ?:(-1.5mm) name in
                            let ru = move-to self (2.5mm *' off, 0pt) in
                            let rd = move-to 
                                  (proj omega (ru, move-to ru (0pt, -1pt))) 
                                  (0pt, 4pt)
                                in
                            [ polyline?:[pc emph-color; lw 1pt] 
                                [omega; rd; ru; self]
                            ; polyline?:[pc emph-color; lw 1pt]
                                [move-to self (4pt, -4pt); self; move-to self (4pt, 4pt)]
                            ]
                          else []
                        )
                      )
                      (destroy-level presense)
                    )
                in concat [[memori]; [ord-node]; omega1-node; destroyer]
          )))
          ords)
        univs
      ; concat-map draw-universe default-universes
      ]

  let diagram = make default-universes default-ordinals
end
